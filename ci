#!/usr/bin/env bash

cat <<INFO
This is the Everest CI script.
... called as $0
... working directory is $(pwd)
... environment: $(uname -a)
INFO

# Sorry, everyone
if (( ${BASH_VERSION%%.*} < 4 )); then
  echo "This script requires Bash >= 4. On OSX, try: brew install bash"
  exit 1
fi

# CI runs [bash -c path/to/ci] without [--login]. This makes sure we have /bin
# and /usr/bin first...!
BUILD_DIR=$(pwd)
source /etc/profile
if [[ -f ~/.bash_profile ]]; then
  source ~/.bash_profile
fi
echo "... PATH is $PATH"
cd "$BUILD_DIR"

# Any error is fatal.
set -e
set -o pipefail
# set -x # uncomment for debugging.

# Some commands...
if [[ $(uname) = "Darwin" ]]; then
  DATE=gdate
else
  DATE=date
fi

# Self-update
echo "... trying to self-update"
if [[ ${0##*/} == $0 ]]; then
  pushd $(dirname $(which $0))
else
  pushd $(dirname $0)
fi
old_revision=$(git rev-parse HEAD)
git fetch
if ! git merge --ff origin/master; then
  echo "WARNING: script cannot self-update"
else
  if [[ $(git rev-parse HEAD) != $old_revision ]]; then
    echo "... new version of CI script available, updated"
    popd
    $0 "$@"
    exit 0
  else
    echo "... no new version available"
  fi
fi
EVEREST_CI_HOME=$(pwd)
popd

# Encode < > & and " in the given string
# The Slack syntax does not require escaping " or \ but JSON does in order to
# form a valid payload.
function quote()
{
  local msg="$1"
  msg=${msg//&/&amp;}
  msg=${msg//</&lt;}
  msg=${msg//>/&gt;}
  msg=${msg//\\/\\\\}
  msg=${msg//\"/\\\"}
  echo $msg
}

# Once we have setup the environment, made errors fatal, and self-upgraded (all
# of which should never fail), we try to report any unexpected failure.
#  $1: channel
#  $2: message
post_to_slack () {
  curl -X POST --data-urlencode "payload={\"channel\": \"$1\", \
    \"username\": \"dzomo\", \"text\": \"$2\", \
    \"icon_emoji\": \":water_buffalo:\"}" "$SLACK_FSTAR_WEBHOOK"
}
trap 'post_to_slack "#everest-build" ":heavy_exclamation_mark: \`$0 $@\` *failed* with error code: $?"' ERR

# Figure out the branch
if [[ $BUILD_SOURCEBRANCHNAME != "" ]]; then
  CI_BRANCH=${BUILD_SOURCEBRANCHNAME##refs/heads/}
  echo "... running in a VSTS environment, branch=$CI_BRANCH"
else
  echo "... trying to figure out the current branch"
  CI_BRANCH=$(git symbolic-ref HEAD) # fails if not on a branch
  CI_BRANCH=${CI_BRANCH##refs/heads/}
  tput setaf 1
  echo "... not running in a VSTS environment, $CI_BRANCH is the working directory's current branch"
  tput sgr0
fi

# Some environment variables we want
export OCAMLRUNPARAM=b
export OTHERFLAGS=--trace_error

log_prelude () {
  # Some basic information
  echo "This is $0 $@"
  echo "Working directory: $(pwd)"
  echo "About to run: $build_command"
  echo "BUILD_SOURCEBRANCHNAME: $BUILD_SOURCEBRANCHNAME"
  echo "BUILD_DEFINITIONNAME: $BUILD_DEFINITIONNAME"
}

# Run a given command and commit & push the logs the the CI_LOGS repository.
# $1: the command to run
# $2: job description without space (e.g. everest-interop or fstar)
# $3: slack channel
# $4: github org/project
run_log_commit () {
  if [[ $CI_LOGS == "" ]]; then
    echo "Don't know where to checkout the logs"
    exit 1
  fi

  build_command="$1"
  stem=$2
  slack_channel=$3
  slack_commit=$(git rev-parse HEAD | cut -c 1-8)
  slack_branch=$CI_BRANCH
  github_project=$4

  # Determine where the logs are going
  local unique_id
  if [[ $BUILD_BUILDNUMBER == "" ]]; then
    echo "... probably running locally, generating a random build number"
    unique_id=$RANDOM
  else
    unique_id=$BUILD_BUILDNUMBER
  fi
  log_all=$stem-$slack_commit-$unique_id.all
  log_err=$stem-$slack_commit-$unique_id.err

  # The actual CI
  SECONDS=0

  if ( log_prelude && $build_command ) \
    2> >( \
      while read -r line; do
        echo "$line" >> $CI_LOGS/$log_err;
        echo "$line" >> $CI_LOGS/$log_all
        echo STDERR: "$line" >&2
      done;
    ) \
    > >( \
      while read -r line; do
        echo "$line" >> $CI_LOGS/$log_all
        echo "$line"
      done
    )
  then
    success=true
  else
    echo "ERROR: PIPESTATUS=${PIPESTATUS[@]}"
    success=false
  fi

  # Commit & push the logs. This does not prevent interleaving from concurrent
  # build jobs.
  pushd $CI_LOGS
  export GIT_MERGE_AUTOEDIT=no
  git pull
  if [ -f $log_all ]; then
    git add $log_all
  fi
  if [ -f $log_err ]; then
    git add $log_err
  fi
  if $success; then
    git commit -am "[CI] $stem logs (success)"
  else
    git commit -am "[CI] $stem logs (failure)"
  fi
  git push
  popd

  if [[ $SLACK_FSTAR_WEBHOOK != "" ]]; then
    raw_url=https://raw.githubusercontent.com/project-everest/ci-logs/master
    slack_log=$(git log --pretty=format:"%s" -1)
    slack_author=$(git log --pretty=format:"%cn" -1)
    slack_time=$(if (( $SECONDS >= 3600 )); then $DATE -d@$SECONDS -u +%Hh%Mm%Ss; else $DATE -d@$SECONDS -u +%Mm%Ss; fi)
    slack_msg="<$raw_url/$log_err|stderr> <$raw_url/$log_all|stdout+stderr>"
    slack_name=$(git remote get-url origin)
    slack_name=${slack_name##*/}
    slack_name=${slack_name%.git}
    slack_os=$(uname)

    if $success; then
      slack_emoji=":white_check_mark:"
      slack_type="success ðŸ˜º"
    else
      slack_emoji=":no_entry:"
      slack_type="failure ðŸ˜¿"
    fi

    # The branch *may* be of the form user_foobar
    maybe_slack_user="${slack_branch%%_*}"

    # Check if the branch has c_ to send to the appropriate channel - otherwise
    # check if the tentative user name is a match using slack-users file
    if [[ ${slack_branch##c_} != $slack_branch ]]; then
      slack_channel=${slack_branch##c_}
      slack_channel="#${slack_channel%%_*}"
    elif egrep ^$maybe_slack_user$ $EVEREST_CI_HOME/slack-users >/dev/null 2>&1; then
      slack_channel="@$maybe_slack_user"
    fi

    # Set up payload. If branch is not c_ or a valid slack name_ then just leave payload as default
    payload="$slack_emoji \`$build_command\` on <https://github.com/$github_project/commit/$slack_commit|$slack_commit> ($slack_branch) is a *$slack_type*\n\
      *Project:* $slack_name\n\
      *Message:* $(quote "$slack_log")\n\
      *Author:* $slack_author\n\
      *Duration:* $slack_time\n\
      *OS:* $slack_os\n\
      *Logs:* $slack_msg\n\
      *VSTS Build definition:* $BUILD_DEFINITIONNAME"

    post_to_slack "$slack_channel" "$payload"
  fi

  if ! $success; then
    exit 255
  fi
}

# Note: this performs an _approximate_ refresh of the hints, in the sense that
# since the hint refreshing job takes about 80 minutes, it's very likely someone
# merged to $CI_BRANCH in the meanwhile, which would invalidate some hints. So, we
# reset to origin/$CI_BRANCH, take in our hints, and push. This is short enough that
# the chances of someone merging in-between fetch and push are low.
refresh_hints () {
  local remote=$1
  local extra="$2"
  local msg="$3"

  # Add all the hints, even those not under version control
  find . -iname '*.hints' | xargs git add
  $extra
  # Abort early if there's nothing to commit
  if git diff --exit-code; then
    return 0
  fi

  git commit -m "[CI] $3"
  # Memorize that commit
  commit=$(git rev-parse HEAD)
  # Move to whatever is the most recent master (that most likely changed in the
  # meantime)
  git fetch
  git checkout $CI_BRANCH
  git reset --hard origin/$CI_BRANCH
  # Silent, always-successful merge
  export GIT_MERGE_AUTOEDIT=no
  git merge $commit -Xtheirs
  # Push.
  git push $remote $CI_BRANCH
}

refresh_fstar_hints () {
  refresh_hints "git@github.com:FStarLang/FStar.git" "git ls-files src/ocaml-output/ | xargs git add" "regenerate hints + ocaml snapshot"
}

refresh_mitls_hints () {
  refresh_hints "git@github.com:mitls/mitls-fstar.git" "true" "regenerate hints"
}

everest_rebuild () {
  git clean -ffdx
  ./everest --yes check reset make
}

everest_move () {
  # This function is called from a test... so it needs to fast-fail because "set
  # -e" does not apply within subshells.

  # VSTS does not clean things properly... no point in fighting that, let's just
  # do it ourselves
  git clean -ffdx
  # Sanity check that will fail if something is off the rails
  ./everest --yes check reset || return 1
  # Update every project to its know good version and branch, then for each
  # project run git pull
  source hashes.sh
  source repositories.sh
  fresh=false
  versions=""
  for r in ${!hashes[@]}; do
    cd $r
    git pull
    if [[ $(git rev-parse HEAD) != ${hashes[$r]} ]]; then
      fresh=true
      url=${repositories[$r]#git@github.com:}
      url="https://www.github.com/${url%.git}/compare/${hashes[$r]}...$(git rev-parse HEAD)"
      versions="$versions\n    *$r* <$url|moves to $(git rev-parse HEAD | cut -c 1-8)> on branch ${branches[$r]}"
    else
      versions="$versions\n    *$r* stays at $(git rev-parse HEAD | cut -c 1-8) on branch ${branches[$r]}"
    fi
    cd ..
  done
  versions="$versions\n"
  if ! $fresh; then
    # Bail out early if there's nothing to do
    post_to_slack "#everest-build" ":information_source: *Nightly Everest Upgrade ($CI_BRANCH):* nothing to upgrade"
  elif ! ./everest --yes make; then
    # Provide a meaningful summary of what we tried
    msg=":no_entry: *Nightly Everest Upgrade ($CI_BRANCH):* upgrading each project to its latest version breaks the build\n$versions"
    post_to_slack "#everest-build" "$msg"
    return 255
  else
    # Life is good, record new revisions and commit. NOTE: this does not include
    # "everest test"... this is a TODO.
    msg=":white_check_mark: *Nightly Everest Upgrade ($CI_BRANCH):* upgrading each project to its latest version works!\n$versions"
    post_to_slack "#everest-build" "$msg"
    ./everest --yes snapshot
    git commit -am "[CI] automatic upgrade"
    rev=$(git rev-parse HEAD)
    git checkout $CI_BRANCH
    git reset --hard origin/$CI_BRANCH
    if ! git merge --ff $rev; then
      echo "Someone else pushed to the everest project in the meanwhile...  aborting."
      exit 1
    fi
    git push git@github.com:project-everest/everest.git $CI_BRANCH

    cd FStar
    if ! git diff --exit-code; then
      echo "New assemblies from Spartan, committing"
      git commit -am "[CI] New assemblies coming from Spartan"
      local commit=$(git rev-parse HEAD)
      local branch=${branches[FStar]}
      git fetch
      git reset --hard origin/$branch
      git merge -Xours $commit
      git push
    fi
    cd ..
  fi
}

docker_from_scratch () {
  (docker run --rm ubuntu bash -c "$(cat ubuntu-from-scratch)" 2>&1 | tee docker-log ) \
    || return 1
  echo "PIPESTATUS=${PIPESTATUS[@]}"
  cat docker-log | grep EVEREST-SUCCESS
}

fetch_fstar_for_mitls () {
  # Oh, VSTS! Also: remove this once every mitls branch has switched to the
  # ocamlbuild version of F*
  git clean -ffdx

  # Clone F* from the specified revision, set FSTAR_HOME
  if [ ! -d fstar ]; then
    mkdir -p fstar
    cd fstar
    git init
    git remote add origin https://github.com/FStarLang/FStar/
    cd ..
  fi
  cd fstar
  # Remove when we stop juggling with the two build systems for F* (old/new)
  git clean -ffdx
  git fetch origin
  git reset --hard $(cat ../.fstar_version)
  make -C src/ocaml-output clean
  make -C src/ocaml-output -j 15
  cd ..
  if command -v cygpath >/dev/null 2>&1; then
    export FSTAR_HOME=$(cygpath -m $(pwd)/fstar)
  else
    export FSTAR_HOME=$(pwd)/fstar
  fi
}

# Main commands.
case "$1" in
  fstar-ci)
    # Run the test suite minus the long tests (e.g. crypto)
    if [ ! -d ulib ]; then
      echo "I don't seem to be in the right directory, bailing"
      exit 1
    fi
    run_log_commit "make -C src utest -j 24 -k" "fstar-ci" "#fstar-build" "FStarLang/FStar"
    ;;

  fstar-nightly)
    # Run the test suite including the long tests and the examples directory
    if [ ! -d ulib ]; then
      echo "I don't seem to be in the right directory, bailing"
      exit 1
    fi
    export OTHERFLAGS="--record_hints --hint_info $OTHERFLAGS"
    run_log_commit "make -C src ulong -j 6 -k" "fstar-nightly" "#fstar-build" "FStarLang/FStar"
    refresh_fstar_hints
    ;;

  mitls-ci)
    if [ ! -f miTLS_icla.txt ]; then
      echo "I don't seem to be in the right directory, bailing"
      exit 1
    fi

    fetch_fstar_for_mitls
    run_log_commit "make -C src/tls -j 24 all-ver -k" "mitls-ci" "#mitls-build" "mitls/mitls-fstar"
    ;;

  mitls-nightly)
    if [ ! -f miTLS_icla.txt ]; then
      echo "I don't seem to be in the right directory, bailing"
      exit 1
    fi

    fetch_fstar_for_mitls
    export OTHERFLAGS="--record_hints --hint_info $OTHERFLAGS"
    run_log_commit "make -C src/tls -j 24 all-ver -k" "mitls-ci" "#mitls-build" "mitls/mitls-fstar"
    refresh_mitls_hints
    ;;


  everest-ci)
    # Clone all projects together and make sure they test and build together
    if ! [ -x everest ]; then
      echo "Not in the right directory"
      exit 1
    fi
    run_log_commit "everest_rebuild" "everest-build" "#everest-build" "project-everest/everest"
    # This second command is only run if the first one succeeds (the script
    # aborts otherwise).
    run_log_commit "./everest --yes test" "everest-test" "#everest-build" "project-everest/everest"
    ;;

  everest-nightly-check)
    # Start a fresh docker container that sets up everything, checks that
    # everything builds and runs on a fresh Ubuntu setup
    if ! [ -f ci ]; then
      echo "Not in the right directory"
      exit 1
    fi
    run_log_commit "docker_from_scratch" "everest-ubuntu" "#everest-build" "project-everest/everest-ci"
    ;;

  everest-nightly-move)
    # Try to move the package to their last revision
    if ! [ -x everest ]; then
      echo "Not in the right directory"
      exit 1
    fi
    run_log_commit "everest_move" "everest-upgrade" "#everest-build" "project-everest/everest"
    ;;

  *)
    cat <<USAGE
USAGE: $0 ACTION

ACTIONS:
  fstar-ci
  fstar-nightly
  mitls-ci
  everest-ci
  everest-nightly-check
  everest-nightly-move

REMARKS:
  Read this script's source code for more explanations. It has comments.
USAGE
    ;;
esac
