#!/usr/bin/env bash

cat <<INFO
This is the Everest CI script.
... called as $0
... working directory is $(pwd)
... environment: $(uname -a)
INFO

# Sorry, everyone
if (( ${BASH_VERSION%%.*} < 4 )); then
  echo "This script requires Bash >= 4. On OSX, try: brew install bash"
  exit 1
fi

# CI runs [bash -c path/to/ci] without [--login]. This makes sure we have /bin
# and /usr/bin first...!
BUILD_DIR=$(pwd)
source /etc/profile
if [[ -f ~/.bash_profile ]]; then
  source ~/.bash_profile
fi
echo "... PATH is $PATH"
cd "$BUILD_DIR"

# Any error is fatal.
set -e
set -o pipefail
# set -x # uncomment for debugging.

# Some commands...
if [[ $(uname) = "Darwin" ]]; then
  DATE=gdate
else
  DATE=date
fi

# Self-update
echo "... trying to self-update"
if [[ ${0##*/} == $0 ]]; then
  pushd $(dirname $(which $0))
else
  pushd $(dirname $0)
fi
old_revision=$(git rev-parse HEAD)
git fetch
if ! git merge --ff origin/master; then
  echo "WARNING: script cannot self-update"
else
  if [[ $(git rev-parse HEAD) != $old_revision ]]; then
    echo "... new version of CI script available, updated"
    popd
    $0 "$@"
    exit 0
  else
    echo "... no new version available"
  fi
fi
EVEREST_CI_HOME=$(pwd)
popd

# $1: channel
# $2: message
post_to_slack () {
  curl -X POST --data-urlencode "payload={\"channel\": \"$1\", \
    \"username\": \"dzomo\", \"text\": \"$2\", \
    \"icon_emoji\": \":water_buffalo:\"}" "$SLACK_FSTAR_WEBHOOK"
}

# Trap any error and show error code
slack_emoji=":no_entry:"
slack_type="ðŸ˜¿"
slack_channel="#everest-build" 
slack_message="$slack_emoji *CI Script FAILED! $slack_type*\n\
    *Message:* The ci script exited abnormally."
trap 'post_to_slack "$slack_channel" "$slack_message Error Code: $?"' ERR

# Figure out the branch
if [[ $BUILD_SOURCEBRANCHNAME != "" ]]; then
  CI_BRANCH=${BUILD_SOURCEBRANCHNAME##refs/heads/}
  echo "... running in a VSTS environment, branch=$CI_BRANCH"
else
  echo "... trying to figure out the current branch"
  CI_BRANCH=$(git symbolic-ref HEAD) # fails if not on a branch
  CI_BRANCH=${CI_BRANCH##refs/heads/}
  tput setaf 1
  echo "... not running in a VSTS environment, $CI_BRANCH is the working directory's current branch"
  tput sgr0
fi

# Some environment variables we want
export OCAMLRUNPARAM=b
export OTHERFLAGS=--trace_error

# $1: the command to run
# $2: job description without space (e.g. everest-interop or fstar)
# $3: slack channel
# $4: github org/project
run_log_commit () {
  if [[ $CI_LOGS == "" ]]; then
    echo "Don't know where to checkout the logs"
    exit 1
  fi

  build_command="$1"
  stem=$2
  slack_channel=$3
  github_project=$4
  slack_branch=$CI_BRANCH

  # Determine where the logs are going
  log_all=$stem-$($DATE +%Y%m%d%H%M%S).all
  log_err=$stem-$($DATE +%Y%m%d%H%M%S).err

  # The actual CI
  SECONDS=0

  if $build_command \
    2> >( \
      while read -r line; do
        echo "$line" >> $CI_LOGS/$log_err;
        echo "$line" >> $CI_LOGS/$log_all
        echo STDERR: "$line" >&2
      done;
    ) \
    > >( \
      while read -r line; do
        echo "$line" >> $CI_LOGS/$log_all
        echo "$line"
      done
    )
  then
    success=true
  else
    echo "ERROR: PIPESTATUS=${PIPESTATUS[@]}"
    success=false
  fi

  # Commit & push the logs. This does not prevent interleaving from concurrent
  # build jobs.
  pushd $CI_LOGS
  export GIT_MERGE_AUTOEDIT=no
  git pull
  if [ -f $log_all ]; then
    git add $log_all
  fi
  if [ -f $log_err ]; then
    git add $log_err
  fi
  if $success; then
    git commit -am "[CI] $stem logs (success)"
  else
    git commit -am "[CI] $stem logs (failure)"
  fi
  git push
  popd

  if [[ $SLACK_FSTAR_WEBHOOK != "" ]]; then
    raw_url=https://raw.githubusercontent.com/project-everest/ci-logs/master
    slack_log=$(git log --pretty=format:"%s" -1)
    slack_author=$(git log --pretty=format:"%cn" -1)
    slack_time=$(if (( $SECONDS >= 3600 )); then $DATE -d@$SECONDS -u +%Hh%Mm%Ss; else $DATE -d@$SECONDS -u +%Mm%Ss; fi)
    slack_msg="<$raw_url/$log_err|stderr> <$raw_url/$log_all|stdout+stderr>"
    slack_commit=$(git rev-parse HEAD | cut -c 1-8)
    slack_name=$(git remote get-url origin)
    slack_name=${slack_name##*/}
    slack_name=${slack_name%.git}
    slack_os=$(uname)

    if $success; then
      slack_emoji=":white_check_mark:"
      slack_type="success ðŸ˜º"
    else
      slack_emoji=":no_entry:"
      slack_type="failure ðŸ˜¿"
    fi

    # The branch *may* be of the form user_foobar
    maybe_slack_user="${slack_branch%%_*}"

    # Check if the branch has c_ to send to the appropriate channel - otherwise
    # check if the tentative user name is a match using slack-users file
    if [[ ${slack_branch##c_} != $slack_branch ]]; then
      slack_channel=${slack_branch##c_}
      slack_channel="#${slack_channel%%_*}"
    elif egrep ^$maybe_slack_user$ $EVEREST_CI_HOME/slack-users >/dev/null 2>&1; then
      slack_channel="@$maybe_slack_user"
    fi

    # Set up payload. If branch is not c_ or a valid slack name_ then just leave payload as default
    payload="$slack_emoji \`$build_command\` on <https://github.com/$github_project/commit/$slack_commit|$slack_commit> ($slack_branch) is a *$slack_type*\n\
      *Project:* $slack_name\n\
      *Message:* $slack_log\n\
      *Author:* $slack_author\n\
      *Duration:* $slack_time\n\
      *OS:* $slack_os\n\
      *Logs:* $slack_msg"

    post_to_slack "$slack_channel" "$payload"
  fi

  if ! $success; then
    exit 255
  fi
}

# Note: this performs an _approximate_ refresh of the hints, in the sense that
# since the hint refreshing job takes about 80 minutes, it's very likely someone
# merged to $CI_BRANCH in the meanwhile, which would invalidate some hints. So, we
# reset to origin/$CI_BRANCH, take in our hints, and push. This is short enough that
# the chances of someone merging in-between fetch and push are low.
refresh_fstar_hints () {
  if ! git remote get-url origin | grep FStar.git; then
    echo "Inconsistency: wrong remote URL"
    exit 1
  fi
  # Add all the hints, even those not under version control
  find . -iname '*.hints' | xargs git add
  git commit -am "[CI] regenerate hints"
  # Memorize that commit
  commit=$(git rev-parse HEAD)
  # Move to whatever is the most recent master (that most likely changed in the
  # meantime)
  git fetch
  git checkout $CI_BRANCH
  git reset --hard origin/$CI_BRANCH
  # Silent, always-successful merge
  export GIT_MERGE_AUTOEDIT=no
  git merge $commit -Xtheirs
  # Push.
  git push git@github.com:FStarLang/FStar.git $CI_BRANCH
}

everest_rebuild () {
  git clean -ffdx
  ./everest --yes check reset make
}

everest_move () {
  # VSTS does not clean things properly... no point in fighting that, let's just
  # do it ourselves
  git clean -ffdx
  # Sanity check that will fail if something is off the rails
  ./everest --yes check reset
  # Update every project to its know good version and branch, then for each
  # project run git pull
  source hashes.sh
  fresh=false
  versions=""
  for r in ${!hashes[@]}; do
    cd $r
    git pull
    if [[ $(git rev-parse HEAD) != ${hashes[$r]} ]]; then
      fresh=true
    fi
    versions="$versions\n    *$r* at $(git rev-parse HEAD | cut -c 1-8) on branch $(git rev-parse --abbrev-ref HEAD)"
    cd ..
  done
  versions="$versions\n"
  if ! $fresh; then
    # Bail out early if there's nothing to do
    post_to_slack "everest-build" "*Nightly Everest Upgrade:* nothing to upgrade"
  elif ! ./everest --yes make; then
    # Provide a meaningful summary of what we tried
    msg=":no_entry: *Nightly Everest Upgrade:* upgrading each project to its latest version breaks the build\n$versions"
    post_to_slack "everest-build" "$msg"
    return 255
  else
    # Life is good, record new revisions and commit. NOTE: this does not include
    # "everest test"... this is a TODO.
    msg=":white_check_mark: *Nightly Everest Upgrade:* upgrading each project to its latest version works!\n$versions"
    post_to_slack "everest-build" "$msg"
    ./everest --yes snapshot
    git commit -am "[CI] automatic upgrade"
    rev=$(git rev-parse HEAD)
    git checkout $CI_BRANCH
    if ! git merge --ff $rev; then
      echo "Someone else pushed to the everest project in the meanwhile...  aborting."
      exit 1
    fi
    git push git@github.com:project-everest/everest.git $CI_BRANCH
  fi
}

docker_from_scratch () {
  docker run ubuntu bash -c "$(cat ubuntu-from-scratch)" 2>&1 | tee docker-log
  echo "PIPESTATUS=${PIPESTATUS[@]}"
  cat docker-log | grep EVEREST-SUCCESS
}

# Main commands.
case "$1" in
  fstar-ci)
    # Run the test suite minus the long tests (e.g. crypto)
    if [ ! -d ulib ]; then
      echo "I don't seem to be in the right directory, bailing"
      exit 1
    fi
    run_log_commit "make -C src utest -j 24 -k" "fstar" "#fstar-build" "FStarLang/FStar"
    ;;

  fstar-nightly)
    # Run the test suite including the long tests and the examples directory
    if [ ! -d ulib ]; then
      echo "I don't seem to be in the right directory, bailing"
      exit 1
    fi
    export OTHERFLAGS="--record_hints --hint_info"
    run_log_commit "make -C src ulong -j 24 -k" "fstar" "#fstar-build" "FStarLang/FStar"
    refresh_fstar_hints
    ;;

  mitls-ci)
    if [ ! -f miTLS_icla.txt ]; then
      echo "I don't seem to be in the right directory, bailing"
      exit 1
    fi

    # Oh, VSTS! Also: remove this once every mitls branch has switched to the
    # ocamlbuild version of F*
    git clean -ffdx

    # Clone F* from the specified revision, set FSTAR_HOME
    if [ ! -d fstar ]; then
      mkdir -p fstar
      cd fstar
      git init
      git remote add origin https://github.com/FStarLang/FStar/
      cd ..
    fi
    cd fstar
    git fetch origin
    git reset --hard $(cat ../.fstar_version)
    make -C src/ocaml-output clean
    make -C src/ocaml-output -j 15
    cd ..
    if command -v cygpath >/dev/null 2>&1; then
      export FSTAR_HOME=$(cygpath -m $(pwd)/fstar)
    else
      export FSTAR_HOME=$(pwd)/fstar
    fi

    run_log_commit "make -C src/tls -j 24 all-ver tls-ffi -k" "miTLS" "#mitls-build" "mitls/mitls-fstar"
    ;;

  everest-ci)
    # Clone all projects together and make sure they test and build together
    if ! [ -x everest ]; then
      echo "Not in the right directory"
      exit 1
    fi
    run_log_commit "everest_rebuild" "everest-build" "#everest-build" "project-everest/everest"
    # This second command is only run if the first one succeeds (the script
    # aborts otherwise).
    run_log_commit "./everest --yes test" "everest-interop" "#everest-build" "project-everest/everest"
    ;;

  everest-nightly-check)
    # Start a fresh docker container that sets up everything, checks that
    # everything builds and runs on a fresh Ubuntu setup
    run_log_commit "docker_from_scratch" "everest-from-scratch-ubuntu" "#everest-build" "project-everest/everest-ci"
    ;;

  everest-nightly-move)
    # Try to move the package to their last revision
    if ! [ -x everest ]; then
      echo "Not in the right directory"
      exit 1
    fi
    run_log_commit "everest_move" "everest-move-to-latest" "#everest-build" "project-everest/everest"
    ;;

  *)
    cat <<USAGE
USAGE: $0 ACTION

ACTIONS:
  fstar-ci
  fstar-nightly
  mitls-ci
  everest-ci
  everest-nightly-check
  everest-nightly-move

REMARKS:
  Read this script's source code for more explanations. It has comments.
USAGE
    ;;
esac

